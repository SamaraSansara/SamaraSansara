from typing import List, Tuple, Optional


#Лексер разбивает исходный текст на токены. Токен — это минимальная значимая единица программы: числа, операторы, ключевые слова, разделители.
class Lexer:
    def __init__(self, data: str):
        self.data = data 
        self.tokens: List[Tuple[str, str]] = [] 
        self.current_pos = 0 
        self.keywords = {'dim', 'if', 'then', 'else', 'for', 'to', 'do', 'while', 'end', 'true', 'false', 'input', 'output'}
        self.operations = {'plus', 'min', 'mult', 'div', 'NE', 'EQ', 'LT', 'LE', 'GT', 'GE', 'and', 'or', '~'}

    def get_next_char(self) -> Optional[str]: 
        if self.current_pos < len(self.data): 
            char = self.data[self.current_pos] 
            self.current_pos += 1 
            return char 
        return None 
    def peek_next_char(self) -> Optional[str]: 
        if self.current_pos < len(self.data): 
            return self.data[self.current_pos] 
        return None 
    def tokenize(self) -> List[Tuple[str, str]]: 
        current_char = self.get_next_char() 
        while current_char is not None: 
            if current_char.isspace():
                current_char = self.get_next_char()
                continue

            if current_char == '(' and self.peek_next_char() == '*':
                self.get_next_char()
                self.tokens.append(('DELIM', '(*'))
                current_char = self.get_next_char()
                token = ""
                while current_char is not None:
                    if current_char == '*' and self.peek_next_char() == ')':
                        self.tokens.append(('IDENTIFICATOR', token.strip()))
                        self.get_next_char()  #  ')'
                        self.tokens.append(('DELIM', '*)'))
                        break
                    token += current_char
                    current_char = self.get_next_char()
                else:
                    raise Exception("Unterminated comment")
                current_char = self.get_next_char()
                continue
            # если встретили цифру, начинаем собирать токен
            if current_char.isdigit():
                token = current_char
                has_alpha = False # Флаг для проверки, если после цифры идет буква
                while self.peek_next_char() and (self.peek_next_char().isalnum() or self.peek_next_char() == '_'):
                    next_char = self.get_next_char()
                    if next_char.isalpha(): # Если встретили букву после цифры
                        has_alpha = True
                    token += next_char
                # Если встретили букву после цифры, это идентификатор
                if has_alpha and token[0].isalpha():
                    self.tokens.append(('IDENTIFICATOR', token))
                elif not has_alpha:
                    self.tokens.append(('NUMBER', token))
                else:
                    self.tokens.append(('UNKNOWN', token))

            elif current_char.isalpha():
                token = current_char
                while self.peek_next_char() and self.peek_next_char().isalnum():
                    token += self.get_next_char()
                if token in self.keywords:
                    self.tokens.append(('KEYWORD', token))
                elif token in self.operations:
                    self.tokens.append(('OPERATION', token))
                else:
                    self.tokens.append(('IDENTIFICATOR', token))

            elif current_char == ':':
                if self.peek_next_char() == '=':
                    self.tokens.append(('OPERATION', ':='))
                    self.get_next_char()
                else:
                    self.tokens.append(('DELIM', ':'))

            elif current_char == '~':
                self.tokens.append(('OPERATION', '~'))

            elif current_char == '(':
                self.tokens.append(('DELIM', '('))
            elif current_char == ')':
                self.tokens.append(('DELIM', ')'))

            elif current_char == ';':
                self.tokens.append(('DELIM', ';'))

            elif current_char == ',':
                self.tokens.append(('DELIM', ','))

            current_char = self.get_next_char()

        return self.tokens
    def print_tokens(self):
        print("\nTokens generated by lexer:") 
        #Объявление функции print_tokens. Она не возвращает ничего, только печатает.
        #Печатает строку "Tokens generated by lexer:" с пустой строкой перед ней, чтобы отделить текст. Это заголовок для списка токенов.
        for token_type, token_value in self.tokens:
            print(f"Token Type: {token_type}, Token Value: {token_value}")

#Проходит по каждому токену в списке self.tokens.
#token_type — тип токена (например, KEYWORD, NUMBER).
#token_value — значение токена (например, dim, 5).
#Печатает токен в формате:
#plaintext
#Копировать код
#Token Type: KEYWORD, Token Value: dim
#Token Type: IDENTIFICATOR, Token Value: a



#Проверяет правильность последовательности токенов и строит дерево синтаксиса программы.
#Parser — это синтаксический анализатор. Он проверяет, правильно ли расположены токены и выполняет инструкции, 
#написанные в программе. Лексер уже разбил текст на токены, теперь парсер понимает, что это за программа и правильно ли она написана.


class Parser:
    def __init__(self, tokens: List[Tuple[str, str]]):
        self.tokens = tokens #это список токенов (кусочки программы).
        self.pos = 0 #текущая позиция в списке токенов (начинается с 0).
        self.current_token = self.tokens[self.pos] if self.tokens else None #текущий токен, с которым работает парсер.

    def advance(self): #Двигается к следующему токену:
        self.pos += 1 #Увеличивает pos на 1.
        self.current_token = self.tokens[self.pos] if self.pos < len(self.tokens) else None #Обновляет current_token, чтобы он стал следующим токеном в списке.

    def match(self, expected_type: str): #Проверяет, соответствует ли текущий токен ожидаемому типу:
        if self.current_token and self.current_token[0] == expected_type: #Если совпадает, переходит к следующему токену с помощью advance().
            self.advance()
        else:
            raise Exception(f"Expected {expected_type}, found {self.current_token}") #Если нет — выдаёт ошибку, потому что синтаксис программы неправильный.
    def program(self): #Это главный метод, который анализирует всю программу:
        while self.current_token and self.current_token[0] != 'KEYWORD' and self.current_token[1] != 'end':
            #Цикл проверяет токены, пока не встретит ключевое слово end.
            if self.current_token[0] == 'KEYWORD' and self.current_token[1] == 'dim':
                self.description()
            #Если встречается dim, вызывает description() для обработки объявления переменных.
            else: #Если нет — обрабатывает операторы с помощью statement().
                self.statement()
            if self.current_token and self.current_token[0] == 'SEMICOLON':
                self.match('SEMICOLON')
        print("Program parsed successfully.")

    def description(self):
        self.match('KEYWORD') 
        self.match('IDENTIFIER') 
        while self.current_token and self.current_token[0] == 'COMMA':  
            self.match('COMMA')
            self.match('IDENTIFIER')  
        self.match('DELIM')  
        self.match('KEYWORD')  
#Проверяет KEYWORD (dim).
#Ищет переменные (IDENTIFIER, например, a, b).
#Обрабатывает запятые и двоеточие.
        
    def statement(self):
        if self.current_token and self.current_token[0] == 'IDENTIFIER':
            self.assignment_statement()
        elif self.current_token and self.current_token[1] == 'if':
            self.if_statement()
        elif self.current_token and self.current_token[1] == 'for':
            self.for_statement()
        elif self.current_token and self.current_token[1] == 'while':
            self.while_statement()
        elif self.current_token and self.current_token[1] == 'input':
            self.input_statement()
        elif self.current_token and self.current_token[1] == 'output':
            self.output_statement()
        else:
            raise Exception("Unknown statement")
#Пытается понять, какой оператор встретился:
#assignment_statement() для присваивания (a := 5 plus 3).
#if_statement() для условных операторов (if a GT b then ...).
#while_statement() для циклов (while a LT b do ...).
#input_statement() для ввода данных.
#output_statement() для вывода данных.
    def assignment_statement(self):
        self.match('IDENTIFICATOR')
        self.match('DELIM')
        self.expression()
#Обрабатывает присваивание:
#a := 5 plus 3;
#Ищет переменную a (IDENTIFICATOR).
#Ищет присваивание := (DELIM).
#Обрабатывает выражение 5 plus 3.

    def if_statement(self):
        self.match('KEYWORD')
        self.expression()
        self.match('KEYWORD')
        self.statement()
        if self.current_token and self.current_token[1] == 'else':
            self.match('KEYWORD')
            self.statement()
#Обрабатывает условный оператор if:
#if a GT b then
    #a := a min b;
#Проверяет условие a GT b.
#Выполняет блок then, а если есть else, обрабатывает его.
    def for_statement(self):
        self.match('KEYWORD')
        self.match('DELIM')
        self.statement()
        self.match('DELIM')

    def while_statement(self):
        self.match('KEYWORD')
        self.expression()
        self.match('KEYWORD')
        self.statement()
#Обрабатывает цикл while:
#while a LT b do
    #a := a div 2;

    def input_statement(self):
        self.match('KEYWORD')
        self.match('DELIM')
        self.match('IDENTIFIER')
        self.match('DELIM')

    def output_statement(self):
        self.match('KEYWORD')
        self.match('DELIM')
        self.expression()
        self.match('DELIM')
#Разбирают ввод и вывод:
#input(a);
#output(a);
    def expression(self):
        self.match('IDENTIFIER')
        while self.current_token and self.current_token[0] == 'OPERATION':
            self.match('OPERATION')
            self.match('IDENTIFICATOR')


data = """
dim a, b : integer;
(* Комментарий *)
a := 5 plus 3;
if a GT b then
    a := a min b;
while a LT b do
    a := a div 2x;
    if a ~ 0 then
        a := a plus 1;
    end_else;
input(a);
output(a);
end;
"""

lexer = Lexer(data)
tokens = lexer.tokenize()
lexer.print_tokens()  # Печать токенов
parser = Parser(tokens)
parser.program()
